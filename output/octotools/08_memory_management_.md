# Chapter 8: Memory Management

Welcome back! In the previous chapter on [Tool Command Generation](07_tool_command_generation_.md), we saw how `octotools` figures out the precise instructions to give a specific tool. Once a tool runs and produces a result, where does that information go? How does `octotools` keep track of what it has done and learned? That's the role of **Memory Management**.

**What's the Problem? Remembering What Happened**

Imagine you're a detective working on a case. You interview witnesses, collect clues, and visit locations. You wouldn't just rely on your immediate memory for everything! You'd keep a detailed case file or notebook. In this notebook, you'd record:
*   The original case description (the main question).
*   Photos or documents you found (evidence/files).
*   Each step you took (e.g., "Interviewed Witness A").
*   What you learned from each step (e.g., "Witness A saw a blue car").

This notebook is essential. It helps you see the big picture, prevents you from repeating steps, allows you to build upon previous findings, and lets you explain your reasoning later.

`octotools` needs a similar system when solving complex problems that require multiple steps. For example, if you ask: "What is the capital of France, and what is its population?" `octotools` might first find the capital (Paris) and then find the population of Paris. It needs to *remember* the first step (finding "Paris") to correctly perform the second step (finding the population *of Paris*).

**Memory Management** in `octotools` is this digital notebook or case file. It's a system for storing and retrieving information about:
1.  The initial query and any input files.
2.  Each action taken during the problem-solving process.
3.  The results of those actions.

This recorded history allows `octotools` to track its progress, use previous results in later steps, and eventually explain how it arrived at the final answer.

**Key Concepts: What's Stored in Memory?**

The `Memory` component in `octotools` keeps track of a few key things:

1.  **The Original Query:** The question you initially asked (e.g., "What is the capital of France, and what is its population?").
2.  **Input Files:** Any files you provided with your query (like images we discussed in [Multimodal Processing](04_multimodal_processing_.md)). It stores the file names and descriptions.
3.  **Actions Taken (Steps):** This is the core of the memory – a log of each step performed during the [Planning-Execution Cycle](02_planning_execution_cycle_.md). For each step, it records:
    *   **Step Number:** The sequence order (1, 2, 3...).
    *   **Tool Used:** Which tool was chosen for this step (e.g., `Web_Search_Tool`).
    *   **Sub-Goal:** What the Planner intended to achieve with this step (e.g., "Find the capital of France").
    *   **Command Executed:** The exact command generated by [Tool Command Generation](07_tool_command_generation_.md) (e.g., `tool.execute(query="capital of France")`).
    *   **Result:** The output returned by the tool after executing the command (e.g., `"Paris"`).

**How is Memory Used? (Internal Process)**

You don't usually interact with the `Memory` object directly. The [Solver Framework](01_solver_framework_.md) manages it automatically as part of the problem-solving process. Here's how it typically happens:

1.  **Setting the Scene:** When you start a query with `solver.solve(question, image_path)`, the Solver tells the Memory about the initial question and any files.

    ```python
    # Inside Solver.solve (Conceptual)
    # Assume 'memory' is the Memory object instance

    # Store the initial question
    memory.set_query(question)

    # If an image file was provided, store its details
    if image_path:
        memory.add_file(file_name=image_path, description="Input image for the query")
    ```
    This code snippet shows the Solver initializing the Memory with the basic details of the task.

2.  **Recording Actions:** During the [Planning-Execution Cycle](02_planning_execution_cycle_.md), after the Executor successfully runs a tool command and gets a result, the Solver updates the Memory.

    ```python
    # Inside the loop in Solver.solve (Conceptual)
    # After executor runs a command for step_count=1

    tool_name = "Web_Search_Tool"
    sub_goal = "Find the capital of France"
    command_details = 'execution = tool.execute(query="capital of France")' # Example command structure
    result = "Paris" # Example result from the tool
    step_count = 1

    # Tell the Memory object to record this completed action
    memory.add_action(
        step_count=step_count,
        tool_name=tool_name,
        sub_goal=sub_goal,
        command=command_details, # Storing the command structure/details
        result=result
    )
    print(f"Step {step_count} result stored in memory.")
    ```
    This snippet shows the critical step where the outcome of an action (using the Web Search Tool to find the capital) is logged in the Memory.

3.  **Using the History:** In subsequent steps of the cycle, the Planner looks at the contents of the Memory (the history of actions and results) to decide what to do next. For example, seeing `"Paris"` in memory helps the Planner plan the next step: "Find the population of Paris". This history is also crucial for [Context Verification](09_context_verification_.md) to check if the overall goal is met.

**Internal Implementation: The Digital Notebook Structure**

Let's look at how the `Memory` component manages this information internally.

1.  **Step-by-Step Flow:**
    *   When the `Solver` starts, it creates a `Memory` object.
    *   It calls `memory.set_query` and `memory.add_file` (if needed).
    *   In each loop of the Planning-Execution Cycle:
        *   The Planner plans a step (potentially using Memory for context).
        *   The Executor generates the command.
        *   The Executor runs the command, getting a `result`.
        *   The `Solver` calls `memory.add_action`, passing the step number, tool name, sub-goal, command details, and the `result`.
        *   The `Memory` object stores this action's details in an internal structure (usually a dictionary).
    *   This continues until the problem is solved. The final Memory contains the complete history.

2.  **Sequence Diagram:**

    ```mermaid
    sequenceDiagram
        participant Solver
        participant Executor
        participant Tool
        participant Memory

        Note over Solver, Memory: Planning-Execution Loop (Step 1)
        Solver->>Executor: Execute command for Tool (e.g., search)
        Executor->>Tool: execute(...)
        Tool-->>Executor: Return result (e.g., "Paris")
        Executor-->>Solver: Execution successful, result="Paris"

        Note over Solver, Memory: Store Action in Memory
        Solver->>Memory: add_action(step=1, tool="Search", goal="Find capital", cmd="...", result="Paris")
        activate Memory
        Memory->>Memory: Store action details internally
        Memory-->>Solver: Action recorded
        deactivate Memory

        Note over Solver, Memory: Continue to next step (using Memory for context)
    ```
    This diagram shows the `Solver` instructing the `Memory` component to record the details of a completed action after the `Executor` provides the result.

3.  **Code Dive (`octotools/models/memory.py`):**
    Let's look at the `Memory` class itself.

    ```python
    # Simplified from octotools/models/memory.py
    from typing import Dict, Any, List, Union, Optional
    import os

    class Memory:

        def __init__(self):
            """Initializes the memory store."""
            self.query: Optional[str] = None # Stores the user's question
            self.files: List[Dict[str, str]] = [] # Stores info about input files
            # Actions are stored in a dictionary, keyed by step name
            self.actions: Dict[str, Dict[str, Any]] = {}
            self._init_file_types() # Helper to manage file descriptions

        def set_query(self, query: str) -> None:
            """Stores the initial query."""
            # ... (type checking) ...
            self.query = query

        def add_file(self, file_name: Union[str, List[str]], ...) -> None:
            """Stores information about input files."""
            # ... (logic to handle single/multiple files and descriptions) ...
            # Simplified: Adds a dictionary like {'file_name': ..., 'description': ...}
            self.files.append({'file_name': file_name, 'description': '...'})

        def add_action(self, step_count: int, tool_name: str, sub_goal: str, command: str, result: Any) -> None:
            """Records the details of a completed action step."""
            action_details = {
                'tool_name': tool_name,
                'sub_goal': sub_goal,
                'command': command, # The command details/structure
                'result': result,   # The output from the tool
            }
            # Use a descriptive key for the step
            step_name = f"Action Step {step_count}"
            # Store the details in the actions dictionary
            self.actions[step_name] = action_details

        def get_actions(self) -> Dict[str, Dict[str, Any]]:
            """Returns the history of all actions taken."""
            return self.actions

        # ... (other methods like get_query, get_files, _init_file_types) ...

    ```
    *   **`__init__`**: Sets up empty storage for the `query`, `files`, and `actions`. The `actions` are stored in a dictionary where keys are step names (like "Action Step 1") and values are dictionaries containing the details of that step.
    *   **`set_query` / `add_file`**: Simple methods to store the initial inputs.
    *   **`add_action`**: This is the core method for logging steps. It takes all the relevant details, bundles them into a dictionary (`action_details`), and stores that dictionary under a specific step name (like `"Action Step 1"`) within the main `self.actions` dictionary.
    *   **`get_actions`**: Allows other components (like the Planner) to retrieve the entire history of actions recorded so far.

This structure provides a clear, step-by-step record of the entire problem-solving process, just like entries in a detective's notebook.

**Conclusion**

Memory Management is the crucial "notebook" for `octotools`. It systematically records the initial query, input files, and every action taken – the tool used, the goal, the command, and the result. This recorded history, managed by the `Memory` component, is essential for tracking progress, allowing the system to build upon previous steps, and enabling verification of the solution. Without this memory, `octotools` couldn't handle multi-step problems effectively.

Now that we understand how `octotools` remembers what it has done, how does it use that memory to check if it has actually gathered enough information to answer your original question? In the next chapter, we'll explore [Context Verification](09_context_verification_.md).

---

Generated by [AI Codebase Knowledge Builder](https://github.com/The-Pocket/Tutorial-Codebase-Knowledge)